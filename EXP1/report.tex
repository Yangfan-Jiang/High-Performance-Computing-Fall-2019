\documentclass{article}
\usepackage[UTF8]{ctex}
\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}

\usepackage{fontspec}

\usepackage{graphicx}
\usepackage{subfigure}

\usepackage{geometry}
\geometry{a4paper,scale=0.70}


\usepackage{listings}
\usepackage{xcolor}

\usetikzlibrary{positioning}


\lstset{
    numbers=left, 
    numberstyle= \tiny, 
    basicstyle = \fontspec{Consolas},
    keywordstyle = \fontspec{Consolas Bold},
    commentstyle = \fontspec{Consolas Italic},
    keywordstyle= \color{ blue!70},
    commentstyle= \color{red!50!green!50!blue!50}, 
    frame=shadowbox, % 阴影效果
    rulesepcolor= \color{ red!20!green!20!blue!20} ,
    escapeinside=``, % 英文分号中可写入中文
    xleftmargin=0.5em,xrightmargin=0.5em, aboveskip=0.5em,
    framexleftmargin=2em,
    language=C,
    showstringspaces=false
} 


\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{\hmwkTitle }
%\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}


\newcommand{\hmwkTitle}{高性能编程实验\#1}
\newcommand{\hmwkAuthorName}{\text{姜洋帆 17341068}}


\title{
    \centering\textbf{ \hmwkTitle}
    \author{\hmwkAuthorName}
}

\renewcommand{\part}[1]{
    \textbf{\large Part \Alph{partCounter}}
    \stepcounter{partCounter}\\
}





\begin{document}

\maketitle

\section{实验内容}
将文件“性能优化实验分析.pdf”中讨论的程序编译运行，并记录运行时间，然后利用Linux性能剖析工具perf分析程序被加速的原因。

\section{相关代码}
实验PDF上给出一个图像旋转的代码(相当于矩阵转置)，并逐步进行三次优化
\subsection{原始代码}
直接使用两重循环，对矩阵进行转置操作，当dim值较大时，cache无法装下矩阵的整行元素，导致局部性不好
\begin{lstlisting}
#include<stdio.h>
#define MAX 4096
#define RIDX(i, j, dim) ((i)*(dim) + (j))
    
typedef struct{
    int red; 
    int green; 
    int blue;
}pixel;
    
void naive_rotate(int dim, pixel *src, pixel *dst)
{
    int i, j;
    for (i = 0; i < dim; i++)
    for (j = 0; j < dim; j++)
        dst[RIDX(dim-1-j, i, dim)] = src[RIDX(i, j, dim)];
}
    
pixel src[MAX*MAX];
pixel dst[MAX*MAX];
    
int main() 
{
    int i;
    for (i = 0; i < 20; i++)
        naive_rotate(MAX, src, dst);
    return 0;
}
\end{lstlisting}

\subsection{第一次尝试}
对矩阵数据进行分块，分为4*4的小块，代码如下
\begin{lstlisting}
#include<stdio.h>
#define MAX 4096
#define RIDX(i, j, dim) ((i)*(dim) + (j))

typedef struct{
    int red; 
    int green; 
    int blue;
}pixel;

void rotate(int dim, pixel *src, pixel *dst)
{
    int i, j, ii, jj;
    for (ii = 0; ii < dim; ii+=4)
    for (jj = 0; jj < dim; jj+=4)
        for (i=ii; i < ii+4; i++)
        for (j=jj; j < jj+4; j++)
            dst[RIDX(dim-1-j, i, dim)] = src[RIDX(i, j, dim)];
}

pixel src[MAX*MAX];
pixel dst[MAX*MAX];

int main() 
{
    int i;
    for (i = 0; i < 20; i++)
        rotate(MAX, src, dst);
    return 0;
}
\end{lstlisting}

\subsection{第二次尝试}
改变分块大小，采用32*32分块，并4*4路循环展开
\begin{lstlisting}
#include<stdio.h>
#define MAX 4096
#define RIDX(i, j, dim) ((i)*(dim) + (j))

typedef struct{
    int red; 
    int green; 
    int blue;
}pixel;

void rotate(int dim, pixel *src, pixel *dst)
{
    int i, j, ii, jj;
    for (ii = 0; ii < dim; ii+=32)
    for (jj = 0; jj < dim; jj+=32)
        for (i=ii; i < ii+32; i+=4)
        for (j=jj; j < jj+32; j+=4) {
            dst[RIDX(dim-1-j, i, dim)]   = src[RIDX(i, j, dim)];
            dst[RIDX(dim-1-j, i+1, dim)] = src[RIDX(i+1, j, dim)];
            dst[RIDX(dim-1-j, i+2, dim)] = src[RIDX(i+2, j, dim)];
            dst[RIDX(dim-1-j, i+3, dim)] = src[RIDX(i+3, j, dim)];
            
            dst[RIDX(dim-1-j-1, i, dim)]   = src[RIDX(i, j+1, dim)];
            dst[RIDX(dim-1-j-1, i+1, dim)] = src[RIDX(i+1, j+1, dim)];
            dst[RIDX(dim-1-j-1, i+2, dim)] = src[RIDX(i+2, j+1, dim)];
            dst[RIDX(dim-1-j-1, i+3, dim)] = src[RIDX(i+3, j+1, dim)];
            
            dst[RIDX(dim-1-j-2, i, dim)]   = src[RIDX(i, j+2, dim)];
            dst[RIDX(dim-1-j-2, i+1, dim)] = src[RIDX(i+1, j+2, dim)];
            dst[RIDX(dim-1-j-2, i+2, dim)] = src[RIDX(i+2, j+2, dim)];
            dst[RIDX(dim-1-j-2, i+3, dim)] = src[RIDX(i+3, j+2, dim)];
            
            dst[RIDX(dim-1-j-3, i, dim)]   = src[RIDX(i, j+3, dim)];
            dst[RIDX(dim-1-j-3, i+1, dim)] = src[RIDX(i+1, j+3, dim)];
            dst[RIDX(dim-1-j-3, i+2, dim)] = src[RIDX(i+2, j+3, dim)];
            dst[RIDX(dim-1-j-3, i+3, dim)] = src[RIDX(i+3, j+3, dim)];
        }
}

pixel src[MAX*MAX];
pixel dst[MAX*MAX];

int main() 
{
    int i;
    for (i = 0; i < 20; i++)
        rotate(MAX, src, dst);
    return 0;
}
\end{lstlisting}




\subsection{最后的尝试}
矩形分块32*1，32路循环展开，并使dest地址连续，以减少存储器写次数
\begin{lstlisting}
#include<stdio.h>
#define MAX 4096
#define RIDX(i, j, dim) ((i)*(dim) + (j))
#define COPY(d, s) *(d) = *(s)

typedef struct{
    int red; 
    int green; 
    int blue;
}pixel;

void rotate(int dim, pixel *src, pixel *dst)
{
    int i, j;
    for (i=0; i < dim; i+=32)
    for (j=dim-1; j >= 0; j-=1) {
        pixel *dptr = dst+RIDX(dim-1-j,i,dim);
        pixel *sptr = src+RIDX(i,j,dim);
        COPY(dptr   , sptr);sptr+=dim; COPY(dptr+1 , sptr);sptr+=dim;
        COPY(dptr+2 , sptr);sptr+=dim; COPY(dptr+3 , sptr);sptr+=dim;
        COPY(dptr+4 , sptr);sptr+=dim; COPY(dptr+5 , sptr);sptr+=dim;
        COPY(dptr+6 , sptr);sptr+=dim; COPY(dptr+7 , sptr);sptr+=dim;
        COPY(dptr+8 , sptr);sptr+=dim; COPY(dptr+9 , sptr);sptr+=dim;
        COPY(dptr+10, sptr);sptr+=dim; COPY(dptr+11, sptr);sptr+=dim;
        COPY(dptr+12, sptr);sptr+=dim; COPY(dptr+13, sptr);sptr+=dim;
        COPY(dptr+14, sptr);sptr+=dim; COPY(dptr+15, sptr);sptr+=dim;
        COPY(dptr+16, sptr);sptr+=dim; COPY(dptr+17, sptr);sptr+=dim;
        COPY(dptr+18, sptr);sptr+=dim; COPY(dptr+19, sptr);sptr+=dim;
        COPY(dptr+20, sptr);sptr+=dim; COPY(dptr+21, sptr);sptr+=dim;
        COPY(dptr+22, sptr);sptr+=dim; COPY(dptr+23, sptr);sptr+=dim;
        COPY(dptr+24, sptr);sptr+=dim; COPY(dptr+25, sptr);sptr+=dim;
        COPY(dptr+26, sptr);sptr+=dim; COPY(dptr+27, sptr);sptr+=dim;
        COPY(dptr+28, sptr);sptr+=dim; COPY(dptr+29, sptr);sptr+=dim;
        COPY(dptr+30, sptr);sptr+=dim; COPY(dptr+31, sptr);
    }
}

pixel src[MAX*MAX];
pixel dst[MAX*MAX];

int main() 
{
    int i;
    for (i = 0; i < 20; i++)
        rotate(MAX, src, dst);
    return 0;
}
\end{lstlisting}

\section{实验结果与分析}
使用perf工具分析程序性能，在具体实现过程中，将图像的两个维度大小定为4096。
同时为了方便观察各版本运行时间以及降低初始化等操作对时间开销的影响，每个版本的
代码都将转置操作重复执行20次。
\newline 在使用perf时，选择task-clock,cycles,instructions,cache-misses,cache-references
L1-dcache-load-misses这几个性能事件，观察不同版本程序之间的区别，实验结果如下：

\subsection{原始代码}
\begin{figure}[htpb]
    \centering
    \includegraphics[width=15cm]{code1.png}    
    \caption{Naive Rotate}
\end{figure}
可以看到，原始代码的运行时间为5.57秒，cache miss次数为1,176,577,616，L1 cache miss次数为906,728,585

\subsection{第一次尝试}
\begin{figure}[htpb]
    \centering
    \includegraphics[width=15cm]{code2.png}
    \caption{第一次尝试}
\end{figure}
进行4*4数据分块后，发现运行时间从5.57秒下降到1.97秒。可以发现两者perf跑出来的
结果主要区别在cache-misses 和 L1-dcache-load-misses这两个指标上。改进后的
代码这两个指标都比源代码小，说明改进后的代码由于划分了数据块，使得数据更加
适应cpu的cache，可以充分利用cache，提高局部性从而提升性能

\subsection{第二次尝试}
\begin{figure}[htpb]
    \centering
    \includegraphics[width=15cm]{code3.png} 
    \caption{第二次尝试}
\end{figure}
采用32*32分块，同时进行4*4路循环展开，运行时间降到1.43秒。这一步主要有两个
方面的优化：数据块划分和循环展开。采用更加合适的数据块划分，进一步优化访存
利用局部性减少cache miss，可以看到cache miss次数进一步下降，降低了访存
压力。同时对循环进行展开，这样的好处是可以有效发挥处理器指令集并行的能力
，提高循环体执行效率，可以看到每周期执行的指令数与上一个版本相比有了略微的
提升。

\subsection{最后的尝试}
\begin{figure}[htpb]
    \centering
    \includegraphics[width=15cm]{code4.png} 
    \caption{第三次尝试}
\end{figure}
矩形分块32*1，32路循环展开，并使dest地址连续，访存次数进一步减少，通过
使dest地址连续，定义宏函数拷贝等方式，降低访存压力；通过循环展开提升CPU
指令级并行的工作效率，最终运行时间降到1.11秒


\end{document}
