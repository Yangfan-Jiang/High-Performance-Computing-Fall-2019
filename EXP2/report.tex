\documentclass{article}
\usepackage[UTF8]{ctex}
\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}

\usepackage{fontspec}

\usepackage{graphicx}
\usepackage{subfigure}

\usepackage{geometry}
\geometry{a4paper,scale=0.70}


\usepackage{listings}
\usepackage{xcolor}

\usetikzlibrary{positioning}


\lstset{
    numbers=left, 
    numberstyle= \tiny, 
    basicstyle = \fontspec{Consolas},
    keywordstyle = \fontspec{Consolas Bold},
    commentstyle = \fontspec{Consolas Italic},
    keywordstyle= \color{ blue!70},
    commentstyle= \color{red!50!green!50!blue!50}, 
    frame=shadowbox, % 阴影效果
    rulesepcolor= \color{ red!20!green!20!blue!20} ,
    escapeinside=``, % 英文分号中可写入中文
    xleftmargin=0.5em,xrightmargin=0.5em, aboveskip=0.5em,
    framexleftmargin=2em,
    language=C,
    showstringspaces=false
} 


\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{\hmwkTitle }
%\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}


\newcommand{\hmwkTitle}{高性能编程实验\#2}
\newcommand{\hmwkAuthorName}{\text{姜洋帆 17341068}}


\title{
    \centering\textbf{ \hmwkTitle}
    \author{\hmwkAuthorName}
}

\renewcommand{\part}[1]{
    \textbf{\large Part \Alph{partCounter}}
    \stepcounter{partCounter}\\
}





\begin{document}

\maketitle

\section{Tasks}
用pthread完成稠密矩阵向量乘法的并行算法$y=Ax$
\begin{itemize}
    \item 测试NUMA非一致性访问的影响
    \item 测试伪共享的影响
\end{itemize}

\section{Data Generation}
\textbf{通过以下代码来生成数据，程序接受两个参数，分别作为生成的矩阵的行和列大小}
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>

int M, N;

int main(int argc, char* argv[])
{
    int i, j, num;
    FILE* fp;
    M = atoi(argv[1]);
    N = atoi(argv[2]);
    
    fp = fopen("data", "w");
    fprintf(fp, "%d %d\n", M, N);
    for(i=0; i<M; i++) {
        for(j=0; j<N; j++) {
            num = rand()%1000;
            fprintf(fp, "%d\n", i, j, num);
        }
    }
    fclose(fp);
    return 0;
}
\end{lstlisting}

\textbf{generate.sh}

\begin{lstlisting}
gcc -o d data_generation.c
./d $1 $2
\end{lstlisting}


\section{NUMA}
\subsection{Method}
通过绑核操作,使线程强制绑定在某个CPU上,让CPU优先使用靠近的存储。
绑核操作主要使用pthread库中的pthread\_setaffinity\_np函数来实现
\subsection{Codes}
\textbf{使用pthread实现并行矩阵向量乘法，主要的运算操作代码入下：}
\begin{lstlisting}
void* multiply(void *data) {
    int start, end, i, j;
    if (set_cpu(++num_cpu)) 
        return NULL;
    
    v *d = (v*)data;
    start = d->i;
    end = d->j;
    for(i=start; i<=end; i++) {
        for(j=0; j<N; j++) {
            y[i][0] += x[j]*A[i][j];
        }
    }
}
\end{lstlisting}

\textbf{
使用pthread进行并行化(按y向量的行来划分任务)
}
\begin{lstlisting}
for(i=0; i < NUM_THREADS; i++) {
    v *data = (v*)malloc(sizeof(v));
    data->i = i*(M / NUM_THREADS);
    data->j = (i+1)*(M / NUM_THREADS)-1;
    pthread_create(&tid[i], &attr, multiply, (void*) data);
}
\end{lstlisting}

\textbf{绑核操作}
\begin{lstlisting}
inline int set_cpu(int i) {
    cpu_set_t mask;  
    CPU_ZERO(&mask);  
    CPU_SET(i,&mask);  

    if(-1 == pthread_setaffinity_np(pthread_self() , \
            sizeof(mask),&mask))  
    {  
        fprintf(stderr, "pthread_setaffinity_np erro\n");  
        return -1;  
    }  
}
\end{lstlisting}

\textbf{
numa.sh:编译执行两个程序，为了保证程序正确，对绑核前后的程序输出进行比对
}

\begin{lstlisting}
icpc -o a matrix.c -g -lpthread
icpc -o _numa matrix_numa.c -g -lpthread

sudo perf stat -d ./a
echo "---- NUMA case -----"
sudo perf stat -d ./_numa

echo "------ verify result ------"
file1=result1
file2=result_numa
diff $file1 $file2 > /dev/null
if [ $? == 0 ]
then
    echo "verify successfully!"
else
    echo "!! wrong answer !!"
fi
\end{lstlisting}

\subsection{Result}
在实际测试时，对向量乘法操作进行100次循环，并使用内置计时函数，
只计时这100次循环的耗时并输出，测试结果如下
\begin{figure}[htpb]
    \centering
    \includegraphics[scale=0.65]{numa.png}    
    \caption{NUMA TEST}
\end{figure}
绑核后，计时部分的时间开销从单位4.9下降到单位4.13,性能得到提升,并且程序执行结果正确

\section{Cache False Sharing}
\subsection{Method}
程序访存压力主要来自于$y_i = \sum_{j}^{N}x_jA_{ij}$这一条操作,查看
实验集群操作系统文件,发现L1 Cache Line大小为64,换算为int数据应该为16个。在划任务
时，每个线程分配两行数据，所以将y数组改为二维数组，列数填充为8，这样每个线程
分到的数据就会是16个int大小，刚好一个cache line避免伪共享
\subsection{Codes}
\textbf{False Sharing Case}
\begin{lstlisting}
...
int *y;
y = (int*)malloc(sizeof(int)*M);
...
\end{lstlisting}

\textbf{数组扩充后}
\begin{lstlisting}
int **y;
y = (int**)malloc(sizeof(int*)*M);

// 填充向量y,每个进程读16个int
for(i=0; i<M; i++) {
    y[i] = (int*)malloc(sizeof(int)*8);
}
\end{lstlisting}

\textbf{run.sh}
\begin{lstlisting}
icpc -o a matrix.c -g -lpthread
icpc -o b false_sharing.c -g -lpthread

sudo perf stat -d ./a
echo "---- Cacahe false sharing case -----"
sudo perf stat -d ./b

echo "------ verify result ------"
file1=result1
file2=result2
diff $file1 $file2 > /dev/null
if [ $? == 0 ]
then
    echo "verify successfully!"
else
    echo "!! wrong answer !!"
fi
\end{lstlisting}


\subsection{Result}
使用Vtune进行性能分析，查看访存压力差别，profile参数为amplex-cl 
-collec general-exploration ./xxx,
结果如下

\begin{figure}[htpb]
    \centering
    \includegraphics[scale=0.45]{false_sharing.png}
    \caption{伪共享}
\end{figure}

\begin{figure}[htpb]
    \centering
    \includegraphics[scale=0.45]{normal.png}
    \caption{优化后}
\end{figure}
可以看到，时间从2.6降到1.3，并且访存压力减轻得十分明显\newline
\textbf{完整代码以及生成的数据、vtune报告见附件}


\end{document}
